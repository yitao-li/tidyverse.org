---
output: hugodown::hugo_document

slug: coro-1-0-0
title: Coroutines for R!
date: 2020-12-10
author: Lionel Henry
description: >
    A 2-3 sentence description of the post that appears on the articles page.
    This can be omitted if it would just recapitulate the title.

photo:
  url: https://unsplash.com/photos/n6vS3xlnsCc
  author: Kelley Bozarth

categories: [package]
tags: []
---

<!--
TODO:
* [ ] Pick category and tags (see existing with `post_tags()`)
* [ ] Find photo & update yaml metadata
* [ ] Create `thumbnail-sq.jpg`; height and width should be equal
* [ ] Create `thumbnail-wd.jpg`; width should be >5x height
* [ ] `hugodown::use_tidy_thumbnail()`
* [ ] Add intro sentence
* [ ] `use_tidy_thanks()`
-->

It is with cheerful merriment that we announce the first release of [coro](https://coro.r-lib.org/)! coro implements coroutines for R, a kind of functions that can suspend and resume themselves before their final `return()`. Coroutines have proved to be extremely useful in other languages for creating complex lazy sequences (with generators) and concurrency code that is easy for humans to read and write (with async functions).

You can install coro from CRAN with:

```{r, eval = FALSE}
install.packages("coro")
```

This blog post will introduce the two sorts of coroutines implemented in coro, generators and coroutines. It will also demonstrate how to use these coroutines in your workflow for existing packages like reticulate and shiny.

```{r setup}
library(coro)
```

## Coroutines

Coroutines are a special sort of functions that can suspend themselves and resume later on. There are two kinds:

- Generators which produce values for complex sequences lazily (that is, on demand). These sequences may be infinite or may produce values that are too large to be held in memory all at once. 

- Async functions which work together with a scheduler of concurrent functions. Async functions suspend themselves when they can't make progress until some computation has finished or some event has occurred. The scheduler gets back control and is free to launch a new concurrent computation or resume a suspended async function that is now ready to make progress.

The common property of all coroutines is that they start to perform some work, decide they have done enough for now and return control to their caller who decides when to call them again to do some more work.

Generators communicate intermediate values to you, the caller. Async functions exclusively communicate with a scheduler. You won't see intermediate values produced by an async function. The suspension mechanism is designed to be transparent to the user and give the illusion of sequential evaluation.

A normal function can only return once:

```{r}
my_function <- function() {}
```

## Topic 2

## Acknowledgements

