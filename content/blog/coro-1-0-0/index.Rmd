---
output: hugodown::hugo_document

slug: coro-1-0-0
title: Coroutines for R!
date: 2020-12-10
author: Lionel Henry
description: >
    A 2-3 sentence description of the post that appears on the articles page.
    This can be omitted if it would just recapitulate the title.

photo:
  url: https://unsplash.com/photos/n6vS3xlnsCc
  author: Kelley Bozarth

categories: [package]
tags: []
---

<!--
TODO:
* [ ] Pick category and tags (see existing with `post_tags()`)
* [ ] Find photo & update yaml metadata
* [ ] Create `thumbnail-sq.jpg`; height and width should be equal
* [ ] Create `thumbnail-wd.jpg`; width should be >5x height
* [ ] `hugodown::use_tidy_thumbnail()`
* [ ] Add intro sentence
* [ ] `use_tidy_thanks()`
-->

It is with sprouting merriment that we announce the first release of [coro](https://coro.r-lib.org/)! coro implements coroutines for R, a kind of functions that can suspend and resume themselves before their final `return()`. Coroutines have proved to be extremely useful in other languages for creating complex lazy sequences (with generators) and concurrency code that is easy for humans to read and write (with async functions).

You can install coro from CRAN with:

```{r, eval = FALSE}
install.packages("coro")
```

This blog post will introduce the two sorts of coroutines implemented in coro, generators and coroutines. It will also demonstrate how to use these coroutines in your workflow for existing packages like reticulate and shiny.

```{r setup}
library(coro)
```

## Coroutines

Coroutines are a special sort of functions that can suspend themselves and resume later on. There are two kinds:

- Generators which produce values for complex sequences lazily (that is, on demand). These sequences may be infinite or may produce values that are too large to be held in memory all at once. 

- Async functions which work together with a scheduler of concurrent functions. Async functions suspend themselves when they can't make progress until some computation has finished or some event has occurred. The scheduler gets back control and is free to launch a new concurrent computation or resume a suspended async function that is now ready to make progress.

The common property of all coroutines is that they start to perform some work, decide by themselves that they have done enough for now, and return an intermediate value to their caller. It is the caller which decides when to call them again to do some more work. Whereas generators communicate intermediate values to you, the user, async functions exclusively communicate in the background with a scheduler of concurrent computations.


## Generators

The term "generator" may refer to two sorts of functions:

- A generator factory
- A generator instance

`coro::generator()` creates generator factories. These factories in turn create fresh generator instances. Generator factories look like normal functions for the most part, except that you can `yield()` values.

```{r}
# Create a generator factory
generate_abc <- generator(function() {
  yield("a")
  yield("b")
  "c"
})
```

The other difference with normal functions is that generator factories don't return a value immediately. They return a function object, a fresh generator instance.

```{r}
# Create a generator instance
abc <- generate_abc()

abc
```

Calling a generator _yields_ a value. It can yield as many time as necessary. The last value is _returned_, after which the generator is stale and returns an exhaustion value.

```{r}
abc()

abc()

abc()

abc()

abc()

is_exhausted(abc())
```

Generators can `yield()` flexibly inside `if` branches, loops, or `tryCatch()` expressions. For instance we could rewrite the `abc` generator with a loop:

```{r}
generate_abc <- generator(function() {
 for (x in letters[1:3]) {
   yield(x)
 }
})
```


### Working with iterators

Technically, generator instances are __iterator__ functions. Calling them repeatedly advances the iteration step by step until exhaustion. coro provides two helpers that make it easy to work with iterator functions.

-   `coro::loop()` instruments `for` so that it understands how to loop over these iterators:

    ```{r}
    loop(for (x in generate_abc()) {
      print(toupper(x))
    })
    ```

-   `coro::collect()` loops over the iterator and collects all values in a list:

    ```{r}
    collect(generate_abc())
    ```

In a generator function, all `for` loops natively understand iterators. This makes it easy to chain generators. A generator that takes other generators as input to modify their values is called an _adaptor_:

```{r}
adapt_prefix <- generator(function(it, prefix) {
  for (x in it) {
    yield(paste0(prefix, x))
  }
})

library(magrittr)

generate_abc() %>% adapt_prefix("foo_") %>% collect()
```


### Compatibility with reticulate

Python iterators from the [reticulate](https://rstudio.github.io/reticulate/) package are fully compatible with coro. Let's create a Python generator for the first `n` integers:

```{r}
suppressMessages(
  library(reticulate)
)

py_run_string("
def first_n(n):
    num = 1
    while num <= n:
        yield num
        num += 1
")
```

You can `loop()` over iterators created by this generator:

```{r}
first_3 <- py$first_n(3)

loop(for (x in first_3) {
  print(x * 2)
})
```

You can `collect()` the values:

```{r}
collect(py$first_n(3))
```

And you can chain them with coro generators:

```{r}
adapt_plus <- generator(function(it, n) {
  for (x in it) yield(x + n)
})

py$first_n(3) %>% adapt_plus(10) %>% collect()
```


### When should I use generators?

Generators are important in Python because they provide a flexible way of creating iterators and these are at the heart of the language. However, whereas Python is scalar oriented, R is a vector oriented language. Also, R is a functional language which makes iterators a bit at odds because they are _stateful_. Advancing an iterator changes the world irremediably. If you want to produce the last value again, you need to start over. For these reasons, generators are likely not the most appropriate way of solving your problems. In most cases it will be more efficient and natural to work with vectorised or functional idioms.

On the other hand, vectorised idioms do not work well when:

- The data doesn't fit in memory. Infinite sequences are an extreme case of this. When you can't work with all the data at once, it must be chunked into more manageable slices.

- The sequence is complex or you don't need to compute all of it in advance.

Generators are a good way of structuring computations on chunked data and lazy sequences.


## Async functions

The most useful application of generators is to create concurrent computations that yield to each other so that they can both make progress in a given lapse of time.

NOTE: You won't see intermediate values produced by an async function. The suspension mechanism is designed to be transparent to the user and give the illusion of sequential evaluation.


## Acknowledgements

